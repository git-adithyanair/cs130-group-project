// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: errand.sql

package db

import (
	"context"
)

const createErrand = `-- name: CreateErrand :one
INSERT INTO errands (
    user_id, 
    community_id
) VALUES (
    $1, $2
) RETURNING id, user_id, community_id, is_complete, created_at, completed_at
`

type CreateErrandParams struct {
	UserID      int64 `json:"user_id"`
	CommunityID int64 `json:"community_id"`
}

func (q *Queries) CreateErrand(ctx context.Context, arg CreateErrandParams) (Errand, error) {
	row := q.db.QueryRowContext(ctx, createErrand, arg.UserID, arg.CommunityID)
	var i Errand
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CommunityID,
		&i.IsComplete,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const deleteErrand = `-- name: DeleteErrand :exec
DELETE FROM errands WHERE id = $1
`

func (q *Queries) DeleteErrand(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteErrand, id)
	return err
}

const getErrand = `-- name: GetErrand :one
SELECT id, user_id, community_id, is_complete, created_at, completed_at FROM errands WHERE id = $1
`

func (q *Queries) GetErrand(ctx context.Context, id int64) (Errand, error) {
	row := q.db.QueryRowContext(ctx, getErrand, id)
	var i Errand
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CommunityID,
		&i.IsComplete,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getErrandsByCommunityId = `-- name: GetErrandsByCommunityId :many
SELECT id, user_id, community_id, is_complete, created_at, completed_at FROM errands 
WHERE community_id = $1
LIMIT $2
OFFSET $3
`

type GetErrandsByCommunityIdParams struct {
	CommunityID int64 `json:"community_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

func (q *Queries) GetErrandsByCommunityId(ctx context.Context, arg GetErrandsByCommunityIdParams) ([]Errand, error) {
	rows, err := q.db.QueryContext(ctx, getErrandsByCommunityId, arg.CommunityID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Errand{}
	for rows.Next() {
		var i Errand
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CommunityID,
			&i.IsComplete,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getErrandsByUserId = `-- name: GetErrandsByUserId :many
SELECT id, user_id, community_id, is_complete, created_at, completed_at FROM errands WHERE user_id = $1
`

func (q *Queries) GetErrandsByUserId(ctx context.Context, userID int64) ([]Errand, error) {
	rows, err := q.db.QueryContext(ctx, getErrandsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Errand{}
	for rows.Next() {
		var i Errand
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CommunityID,
			&i.IsComplete,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listErrands = `-- name: ListErrands :many
SELECT id, user_id, community_id, is_complete, created_at, completed_at FROM errands 
LIMIT $1
OFFSET $2
`

type ListErrandsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListErrands(ctx context.Context, arg ListErrandsParams) ([]Errand, error) {
	rows, err := q.db.QueryContext(ctx, listErrands, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Errand{}
	for rows.Next() {
		var i Errand
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CommunityID,
			&i.IsComplete,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateErrand = `-- name: UpdateErrand :one
UPDATE errands SET
    user_id = $2, 
    community_id = $3, 
    is_complete = $4
WHERE id = $1
RETURNING id, user_id, community_id, is_complete, created_at, completed_at
`

type UpdateErrandParams struct {
	ID          int64 `json:"id"`
	UserID      int64 `json:"user_id"`
	CommunityID int64 `json:"community_id"`
	IsComplete  bool  `json:"is_complete"`
}

func (q *Queries) UpdateErrand(ctx context.Context, arg UpdateErrandParams) (Errand, error) {
	row := q.db.QueryRowContext(ctx, updateErrand,
		arg.ID,
		arg.UserID,
		arg.CommunityID,
		arg.IsComplete,
	)
	var i Errand
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CommunityID,
		&i.IsComplete,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const updateErrandStatus = `-- name: UpdateErrandStatus :one
UPDATE errands SET 
    is_complete = $2,
    completed_at = CASE WHEN $2 = TRUE THEN NOW() 
                        ELSE completed_at END
WHERE id = $1
RETURNING id, user_id, community_id, is_complete, created_at, completed_at
`

type UpdateErrandStatusParams struct {
	ID         int64 `json:"id"`
	IsComplete bool  `json:"is_complete"`
}

func (q *Queries) UpdateErrandStatus(ctx context.Context, arg UpdateErrandStatusParams) (Errand, error) {
	row := q.db.QueryRowContext(ctx, updateErrandStatus, arg.ID, arg.IsComplete)
	var i Errand
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CommunityID,
		&i.IsComplete,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}
